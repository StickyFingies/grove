## **Software Architecture** <a name="chapter-1"></a>

- **ECS**: All game objects ("entities") and their behaviors are logically represented using the [ECS paradigm](https://en.wikipedia.org/wiki/Entity_component_system).  Yeah, the game runs on Javascript and the performance benefits of this are negligable.  On the flip side, building this system has taught me a lot about cache locality and some of the architectural benefits of composition-over-inheritance.
- **Graphics**: This game uses [Three.js](https://github.com/mrdoob/three.js) to both order game objects into a heirarchical scene graph _(main thread)_, and then draw those objects _(render thread)_.  Every frame, the main thread computes individual object transforms, and communicates them to the render thread using [shared memory](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), which uses WebGL to draw the objects.
- **Physics**: Similarly to the renderer, ~~a WASM copy of~~ the Bullet physics engine sits on its own thread and churns out object transforms to the main thread using shared memory.  All memory is write-once read-many, so data races _shouldn't_ (!!!) occur.  I really don't know if offloading major systems like this increases performance by any considerable margin; but again, it was fun for a learning excersize.
- **Engine**: This package wraps together the ECS world, graphics sub-engine, and physics sub-engine, and gets
them all talking to eachother.  It also includes utilities for logging, asset loading (glTF), scene setup, and more.
- **Grove**: This is where all the actualy game code lives.  Every entity behavior is represented as a GameScript,
and so we can use GameScripts to decide what actually happens in the sumulation.  There are GameScripts for the player,
for the camera, for enemies and health bars, and basically everything which exists in the world.