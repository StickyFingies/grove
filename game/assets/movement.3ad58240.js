var k=Object.defineProperty;var C=(e,t,o)=>t in e?k(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var a=(e,t,o)=>(C(e,typeof t!="symbol"?t+"":t,o),o);import{V as p,E as j,w as l,P as x,e as z,C as P,r as R,p as c}from"./game.e9cd2ea9.js";import{smoothCamera as S,SmoothCamera as q}from"./smoothCamera.0f97f940.js";class v{constructor(){a(this,"walkVelocity",0);a(this,"jumpVelocity",0);a(this,"wantsToJump",!1);a(this,"sprinting",!1);a(this,"groundNormal",new p);a(this,"moveForward",!1);a(this,"moveBackward",!1);a(this,"moveLeft",!1);a(this,"moveRight",!1);a(this,"euler",new j(0,0,0,"YXZ"))}}l.addRule({types:[x,z,v],fn([e,t,o]){const i=new p(0,0,0);o.moveForward&&(i.z=-1),o.moveBackward&&(i.z=1),o.moveLeft&&(i.x=-1),o.moveRight&&(i.x=1);const[{object:s,positionStep:y,quaternionStep:u,offsetY:w,offsetZ:d}]=l.get(S,[q]),[f]=l.get(l.getTag(P),[R]);i.applyQuaternion(s.quaternion);const n=i.normalize();n.multiplyScalar(o.walkVelocity),n.multiplyScalar(o.sprinting?5:1);const m=[n.x,0,n.z];c.addVelocity({object:e,vector:m});const r=c.getBodyPosition(e);o.wantsToJump&&c.addVelocityConditionalRaycast({velocity:{object:e,vector:[0,o.jumpVelocity,0]},raycast:{id:0,from:r,to:[r[0],r[1]-2.5,r[2]]}});const[g,V,h]=c.getBodyPosition(e);s.position.copy(new p(g,V+1,h)),s.position.y+=w,s.translateZ(d),f.position.lerp(s.position,y),f.quaternion.slerp(s.quaternion,u),t.rotation.y=Math.PI+o.euler.y}});export{v as Movement};
