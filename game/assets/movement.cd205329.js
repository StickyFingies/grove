var k=Object.defineProperty;var v=(t,o,i)=>o in t?k(t,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[o]=i;var e=(t,o,i)=>(v(t,typeof o!="symbol"?o+"":o,i),i);import{w as c,P as x,d as C,C as j,r as z,p,V as f,E as M}from"./game.86b6fc01.js";import{G as P}from"./script.1f479a83.js";import{smoothCamera as q,SmoothCamera as B}from"./smoothCamera.d2004ac1.js";class R{constructor(){e(this,"walkVelocity",0);e(this,"jumpVelocity",0);e(this,"wantsToJump",!1);e(this,"sprinting",!1);e(this,"groundNormal",new f);e(this,"moveForward",!1);e(this,"moveBackward",!1);e(this,"moveLeft",!1);e(this,"moveRight",!1);e(this,"euler",new M(0,0,0,"YXZ"))}}class G extends P{every_frame(){c.do_with([x,C,R],([o,i,a])=>{const s=new f(0,0,0);a.moveForward&&(s.z=-1),a.moveBackward&&(s.z=1),a.moveLeft&&(s.x=-1),a.moveRight&&(s.x=1);const[{object:r,positionStep:m,quaternionStep:d,offsetY:w,offsetZ:u}]=c.get(q,[B]),[y]=c.get(c.getTag(j),[z]);s.applyQuaternion(r.quaternion);const n=s.normalize();n.multiplyScalar(a.walkVelocity),n.multiplyScalar(a.sprinting?5:1);const g=[n.x,0,n.z];p.addVelocity({object:o,vector:g});const l=p.getBodyPosition(o);a.wantsToJump&&p.addVelocityConditionalRaycast({velocity:{object:o,vector:[0,a.jumpVelocity,0]},raycast:{id:0,from:l,to:[l[0],l[1]-2.5,l[2]]}});const[V,h,S]=p.getBodyPosition(o);r.position.copy(new f(V,h+1,S)),r.position.y+=w,r.translateZ(u),y.position.lerp(r.position,m),y.quaternion.slerp(r.quaternion,d),i.rotation.y=Math.PI+a.euler.y})}}export{R as Movement,G as default};
